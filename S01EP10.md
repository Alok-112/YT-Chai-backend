# User & Video Models with JWT Authentication - Complete Guide

## ğŸ“‹ Table of Contents
1. [User Model Implementation](#user-model-implementation)
2. [Video Model with Aggregation](#video-model-with-aggregation)
3. [Password Security with Bcrypt](#password-security-with-bcrypt)
4. [JWT Authentication System](#jwt-authentication-system)
5. [Mongoose Hooks & Middleware](#mongoose-hooks--middleware)
6. [Database Optimization](#database-optimization)
7. [Production Best Practices](#production-best-practices)

---

# User Model Implementation

## ğŸ‘¤ Complete User Schema

### **`src/models/user.model.js`**
```javascript
import mongoose, { Schema } from "mongoose"
import jwt from "jsonwebtoken"
import bcrypt from "bcrypt"

const userSchema = new Schema(
  {
    username: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      index: true, // Optimized for search operations
    },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
    },
    fullName: {
      type: String,
      required: true,
      trim: true,
      index: true, // Frequently searched field
    },
    avatar: {
      type: String, // Cloudinary URL
      required: true,
    },
    coverImage: {
      type: String, // Cloudinary URL
    },
    watchHistory: [
      {
        type: Schema.Types.ObjectId,
        ref: "Video",
      },
    ],
    password: {
      type: String,
      required: [true, "Password is required"],
    },
    refreshToken: { // Fixed typo: "refereshToken"
      type: String,
    },
  },
  {
    timestamps: true, // Adds createdAt and updatedAt
  }
)

// ============= MIDDLEWARE (HOOKS) =============

// Pre-save hook: Hash password before saving
userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next()
  
  this.password = await bcrypt.hash(this.password, 10) // Fixed: added await
  next()
})

// ============= INSTANCE METHODS =============

// Method to verify password
userSchema.methods.isPasswordCorrect = async function (password) {
  return await bcrypt.compare(password, this.password)
}

// Method to generate access token
userSchema.methods.generateAccessToken = function () {
  return jwt.sign(
    {
      _id: this._id,
      email: this.email,
      username: this.username,
      fullName: this.fullName,
    },
    process.env.ACCESS_TOKEN_SECRET,
    {
      expiresIn: process.env.ACCESS_TOKEN_EXPIRY,
    }
  )
}

// Method to generate refresh token
userSchema.methods.generateRefreshToken = function () {
  return jwt.sign(
    {
      _id: this._id,
    }, // Refresh token carries minimal data
    process.env.REFRESH_TOKEN_SECRET,
    {
      expiresIn: process.env.REFRESH_TOKEN_EXPIRY,
    }
  )
}

export const User = mongoose.model("User", userSchema)
```

---

# Video Model with Aggregation

## ğŸ¥ Advanced Video Schema

### **`src/models/video.model.js`**
```javascript
import mongoose, { Schema } from 'mongoose'
import mongooseAggregatePaginate from 'mongoose-aggregate-paginate-v2'

const videoSchema = new Schema({
    videoFile: {
        type: String, // Cloudinary URL
        required: true,
    },
    thumbnail: {
        type: String, // Cloudinary URL
        required: true,
    },
    title: {
        type: String,
        required: true,
        trim: true,
        index: true, // For search functionality
    },
    description: {
        type: String,
        required: true,
        trim: true,
    },
    duration: {
        type: Number, // Duration in seconds
        required: true,
    },
    views: {
        type: Number,
        default: 0,
    },
    isPublished: {
        type: Boolean,
        default: true,
    },
    owner: {
        type: Schema.Types.ObjectId,
        ref: "User",
        required: true,
    }
}, {
    timestamps: true
})

// Add aggregation pagination plugin
videoSchema.plugin(mongooseAggregatePaginate)

export const Video = mongoose.model("Video", videoSchema) // Fixed: added schema parameter
```

### **Aggregation Pipeline Usage Example:**
```javascript
// Complex video queries with pagination
const getVideosWithStats = async (page = 1, limit = 10) => {
  const aggregate = Video.aggregate([
    // Match published videos
    { $match: { isPublished: true } },
    
    // Lookup owner details
    {
      $lookup: {
        from: "users",
        localField: "owner",
        foreignField: "_id",
        as: "ownerDetails",
        pipeline: [
          {
            $project: {
              username: 1,
              fullName: 1,
              avatar: 1
            }
          }
        ]
      }
    },
    
    // Add computed fields
    {
      $addFields: {
        ownerDetails: { $first: "$ownerDetails" }
      }
    },
    
    // Sort by views (most popular first)
    { $sort: { views: -1 } }
  ])

  // Use pagination plugin
  const options = {
    page: parseInt(page),
    limit: parseInt(limit),
  }

  return await Video.aggregatePaginate(aggregate, options)
}
```

---

# Password Security with Bcrypt

## ğŸ”’ Understanding Bcrypt vs BcryptJS

### **Library Comparison:**

#### **`bcrypt` (Recommended)**
```javascript
import bcrypt from "bcrypt" // Core Node.js C++ implementation
```
**Advantages:**
- âœ… **Faster**: C++ implementation, better performance
- âœ… **More Secure**: Core Node.js library
- âœ… **Industry Standard**: Used by major companies

#### **`bcryptjs`**  
```javascript
import bcryptjs from "bcryptjs" // Pure JavaScript implementation
```
**Advantages:**
- âœ… **No C++ Dependencies**: Easier deployment
- âœ… **Cross-Platform**: Works everywhere
- âŒ **Slower**: Pure JS is slower than C++

### **How Bcrypt Works:**

#### **Password Hashing Process:**
```javascript
// Original password
const plainPassword = "mySecretPassword123"

// Salt rounds (cost factor)
const saltRounds = 10 // 2^10 = 1024 iterations

// Hashing process
const hashedPassword = await bcrypt.hash(plainPassword, saltRounds)
console.log(hashedPassword) 
// Output: $2b$10$N9qo8uLOickgx2ZMRZoMye.IjPeOp.SjmdbdGrOaOa0gJ8./GJ.6u

// Salt rounds breakdown:
// $2b$ - Algorithm identifier
// $10$ - Salt rounds (10)
// Next 22 chars - Salt
// Remaining chars - Hash
```

#### **Password Verification:**
```javascript
const userEnteredPassword = "mySecretPassword123"
const storedHashedPassword = "$2b$10$N9qo8uLOickgx2ZMRZoMye..."

const isMatch = await bcrypt.compare(userEnteredPassword, storedHashedPassword)
console.log(isMatch) // true or false
```

### **Security Considerations:**

#### **Salt Rounds Selection:**
```javascript
const SALT_ROUNDS = {
  DEVELOPMENT: 8,  // Faster for testing
  PRODUCTION: 12,  // More secure, slower
  HIGH_SECURITY: 15 // Very secure, very slow
}

// Rule of thumb: Each additional round doubles the time
// Round 10: ~10ms
// Round 12: ~40ms  
// Round 15: ~300ms
```

---

# JWT Authentication System

## ğŸŸï¸ Complete JWT Implementation

### **What is JWT (JSON Web Token)?**

**JWT is a Bearer Token System:**
- ğŸ”‘ **Bearer Token**: "Whoever bears (carries) this token gets access"
- ğŸ« **Like a concert ticket**: Show the ticket, get access
- ğŸ” **Cryptographic Algorithm**: Ensures token integrity

### **JWT Structure:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

Header.Payload.Signature
```

#### **JWT Components:**
1. **Header**: Algorithm info (`{"alg": "HS256", "typ": "JWT"}`)
2. **Payload**: User data/claims (`{"_id": "123", "username": "john"}`)
3. **Signature**: Verification hash

### **Access Token vs Refresh Token:**

#### **Access Token (Short-lived)**
```javascript
// Contains user info, short expiry
generateAccessToken() {
  return jwt.sign(
    {
      _id: this._id,
      email: this.email,
      username: this.username,
      fullName: this.fullName, // Rich payload
    },
    process.env.ACCESS_TOKEN_SECRET,
    { expiresIn: "15m" } // Short expiry
  )
}
```

#### **Refresh Token (Long-lived)**
```javascript
// Contains minimal info, long expiry  
generateRefreshToken() {
  return jwt.sign(
    {
      _id: this._id, // Minimal payload
    },
    process.env.REFRESH_TOKEN_SECRET,
    { expiresIn: "7d" } // Longer expiry
  )
}
```

### **Token Strategy:**
```javascript
// Login process
const login = async (email, password) => {
  // 1. Verify credentials
  const user = await User.findOne({ email })
  const isPasswordValid = await user.isPasswordCorrect(password)
  
  if (!isPasswordValid) {
    throw new ApiError(401, "Invalid credentials")
  }
  
  // 2. Generate tokens
  const accessToken = user.generateAccessToken()
  const refreshToken = user.generateRefreshToken()
  
  // 3. Save refresh token to database
  user.refreshToken = refreshToken
  await user.save({ validateBeforeSave: false })
  
  // 4. Send tokens to client
  return { accessToken, refreshToken }
}
```

### **Environment Variables Setup:**
```bash
# .env file
ACCESS_TOKEN_SECRET=your-super-secret-access-key-here
ACCESS_TOKEN_EXPIRY=15m

REFRESH_TOKEN_SECRET=your-different-refresh-secret-here  
REFRESH_TOKEN_EXPIRY=7d
```

---

# Mongoose Hooks & Middleware

## ğŸª Understanding Pre/Post Hooks

### **What are Mongoose Hooks?**
**Middleware that runs at specific points in document lifecycle**

### **Types of Middleware:**

#### **1. Pre-Save Hook (Most Common)**
```javascript
// Runs BEFORE saving to database
userSchema.pre("save", async function (next) {
  // 'this' refers to the document being saved
  console.log("About to save user:", this.username)
  
  // Only hash password if it's modified
  if (!this.isModified("password")) return next()
  
  // Hash the password
  this.password = await bcrypt.hash(this.password, 10)
  next() // Continue to save
})
```

#### **2. Post-Save Hook**
```javascript
userSchema.post("save", function (doc, next) {
  console.log("User saved successfully:", doc._id)
  next()
})
```

#### **3. Pre-Remove Hook**
```javascript
userSchema.pre("remove", async function (next) {
  // Cleanup related data before user deletion
  await Video.deleteMany({ owner: this._id })
  next()
})
```

#### **4. Pre-Find Hook**
```javascript
// Runs before any find operation
userSchema.pre(/^find/, function (next) {
  // Auto-populate watchHistory
  this.populate('watchHistory')
  next()
})
```

### **Common Hook Patterns:**

#### **Password Hashing Hook:**
```javascript
userSchema.pre("save", async function (next) {
  // Skip if password hasn't changed
  if (!this.isModified("password")) return next()
  
  try {
    // Hash password with salt rounds
    this.password = await bcrypt.hash(this.password, 12)
    next()
  } catch (error) {
    next(error) // Pass error to next middleware
  }
})
```

#### **Slug Generation Hook:**
```javascript
videoSchema.pre("save", function (next) {
  if (this.isModified("title")) {
    this.slug = this.title
      .toLowerCase()
      .replace(/[^a-zA-Z0-9]/g, '-')
      .replace(/-+/g, '-')
  }
  next()
})
```

---

# Database Optimization

## ğŸš€ Performance & Indexing

### **Understanding Database Indexes:**

**Why Index?**
- ğŸ“ˆ **Faster Queries**: Database can find data quickly
- ğŸ” **Search Optimization**: Essential for frequently searched fields
- âš¡ **Performance**: Reduces query time from seconds to milliseconds

#### **When to Use Indexes:**
```javascript
// Fields that are frequently searched
username: {
  type: String,
  index: true, // Users search by username often
}

fullName: {
  type: String,  
  index: true, // Search users by name
}

// DON'T index everything - it slows down writes
password: {
  type: String,
  // No index - passwords are never searched
}
```

### **Index Strategy Guidelines:**
```javascript
// âœ… Index these fields:
- Search fields (username, email, title)
- Foreign keys (owner, userId)
- Sort fields (createdAt, views)
- Filter fields (isPublished, category)

// âŒ Don't index these:
- Password fields  
- Large text fields (description)
- Fields that change frequently
- Rarely queried fields
```

### **Compound Indexes:**
```javascript
// Index multiple fields together
videoSchema.index({ owner: 1, isPublished: 1 })
videoSchema.index({ createdAt: -1, views: -1 })
```

---

# Production Best Practices

## ğŸ¯ Complete Authentication System

### **Enhanced User Model with Validation:**
```javascript
const userSchema = new Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
    index: true,
    minlength: [3, 'Username must be at least 3 characters'],
    maxlength: [30, 'Username cannot exceed 30 characters'],
    match: [/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers and underscores']
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email']
  },
  password: {
    type: String,
    required: [true, "Password is required"],
    minlength: [8, 'Password must be at least 8 characters'],
    select: false // Don't include in queries by default
  }
})
```

### **Token Refresh Middleware:**
```javascript
// src/middlewares/auth.js
const refreshAccessToken = async (req, res, next) => {
  try {
    const incomingRefreshToken = req.cookies?.refreshToken || req.body.refreshToken
    
    if (!incomingRefreshToken) {
      throw new ApiError(401, "Unauthorized request")
    }
    
    const decodedToken = jwt.verify(incomingRefreshToken, process.env.REFRESH_TOKEN_SECRET)
    const user = await User.findById(decodedToken._id)
    
    if (!user || user.refreshToken !== incomingRefreshToken) {
      throw new ApiError(401, "Invalid refresh token")
    }
    
    const accessToken = user.generateAccessToken()
    const newRefreshToken = user.generateRefreshToken()
    
    user.refreshToken = newRefreshToken
    await user.save({ validateBeforeSave: false })
    
    return res
      .status(200)
      .cookie("accessToken", accessToken, cookieOptions)
      .cookie("refreshToken", newRefreshToken, cookieOptions)
      .json(new ApiResponse(200, { accessToken, refreshToken: newRefreshToken }, "Access token refreshed"))
    
  } catch (error) {
    throw new ApiError(401, error?.message || "Invalid refresh token")
  }
}
```

### **Security Headers & Cookies:**
```javascript
const cookieOptions = {
  httpOnly: true, // Prevents XSS attacks
  secure: process.env.NODE_ENV === "production", // HTTPS only in production
  sameSite: 'strict', // CSRF protection
  maxAge: 24 * 60 * 60 * 1000 // 24 hours
}

// Setting secure cookies
res.cookie("accessToken", accessToken, cookieOptions)
res.cookie("refreshToken", refreshToken, cookieOptions)
```

## ğŸ” Security Best Practices Checklist

### **Password Security:**
- âœ… Use bcrypt with salt rounds 10-12
- âœ… Never store plain text passwords
- âœ… Use `select: false` on password fields
- âœ… Validate password strength

### **JWT Security:**
- âœ… Use different secrets for access/refresh tokens
- âœ… Keep access tokens short-lived (15-30 minutes)
- âœ… Store refresh tokens securely
- âœ… Implement token rotation

### **Database Security:**
- âœ… Index frequently queried fields
- âœ… Validate all inputs
- âœ… Use unique constraints where needed
- âœ… Implement proper error handling

### **Environment Variables:**
```bash
# Production .env example
NODE_ENV=production
MONGODB_URI=mongodb+srv://...
ACCESS_TOKEN_SECRET=complex-random-string-256-bits
REFRESH_TOKEN_SECRET=different-complex-random-string-256-bits
ACCESS_TOKEN_EXPIRY=15m
REFRESH_TOKEN_EXPIRY=7d
CLOUDINARY_CLOUD_NAME=your-cloud-name
CLOUDINARY_API_KEY=your-api-key
CLOUDINARY_API_SECRET=your-api-secret
```

This comprehensive system provides enterprise-grade user authentication with JWT tokens, secure password handling, and optimized database operations! ğŸš€

## Key Takeaways:
- ğŸ”‘ **JWT Bearer Tokens**: Whoever has the token gets access
- ğŸ” **Bcrypt Hashing**: Always hash passwords with proper salt rounds
- ğŸª **Mongoose Hooks**: Automate tasks like password hashing
- ğŸ“Š **Strategic Indexing**: Index searchable fields, not everything
- âš¡ **Aggregation Pipelines**: Complex queries with pagination
- ğŸ›¡ï¸ **Security First**: Validate inputs, use secure cookies, rotate tokens