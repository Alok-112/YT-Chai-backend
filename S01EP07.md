# Professional Backend Project Setup - Complete Guide

## üìã Table of Contents
1. [Project Analysis Phase](#project-analysis-phase)
2. [Initial Project Setup](#initial-project-setup)
3. [Project Structure](#project-structure)
4. [Development Dependencies](#development-dependencies)
5. [Code Formatting Setup](#code-formatting-setup)
6. [Best Practices](#best-practices)

---

# Project Analysis Phase

## üé® From Design to Backend Logic

### **The Professional Workflow:**
1. **UI Engineers** create prototypes in Figma
2. **Frontend Developers** implement the designs
3. **Backend Developers** analyze requirements and build APIs

### **üì± Example: Figma Prototype Analysis**
**Prototype Link:** [PLAY App Prototype](https://www.figma.com/proto/shmxWL5FKRO5GNOPPopBg6/PLAY?node-id=1-38963&p=f&t=bOcy4TEOWsFEZAxy-1&scaling=min-zoom&content-scaling=fixed&page-id=0%3A1)

## üß† Backend Developer's Thinking Process

### **What Backend Developers Analyze:**

#### **1. Data Requirements Analysis**
- **What data needs to be stored?**
  - User profiles, posts, comments, likes
  - Authentication data, preferences
  - Media files, timestamps, relationships

#### **2. Data Types & Formats**
- **Text Data**: Usernames, descriptions, comments
- **Numbers**: Likes count, user IDs, timestamps
- **Booleans**: Privacy settings, verification status
- **Files**: Profile pictures, post images, videos
- **References**: User relationships, post ownership

#### **3. Business Logic Planning**
- **User Authentication**: Login, registration, password reset
- **Content Management**: Create, read, update, delete posts
- **Social Features**: Follow/unfollow, like/unlike
- **Privacy Controls**: Public/private profiles
- **File Handling**: Image/video upload and processing

### **üéØ Key Questions to Ask:**
- What screens need what data?
- How do users interact with the data?
- What relationships exist between data entities?
- What are the security requirements?
- What third-party services are needed?

---

# Initial Project Setup

## üöÄ Step 1: Initialize Project

```bash
# Create project directory
mkdir play-backend
cd play-backend

# Initialize npm project
npm init
```

### **What Happens:**
- Creates `package.json` file
- Defines project metadata (name, version, description)
- Sets up dependency management
- Configures entry point and scripts

## üìÅ Step 2: Project Structure Setup

### **Professional Folder Structure:**
```
play-backend/
‚îú‚îÄ‚îÄ public/              # Temporary file storage
‚îÇ   ‚îú‚îÄ‚îÄ temp/           # Temporary uploads
‚îÇ   ‚îî‚îÄ‚îÄ uploads/        # Processed files
‚îú‚îÄ‚îÄ src/                # Source code
‚îÇ   ‚îú‚îÄ‚îÄ controllers/    # Route handlers
‚îÇ   ‚îú‚îÄ‚îÄ db/            # Database configuration
‚îÇ   ‚îú‚îÄ‚îÄ middlewares/   # Custom middleware functions
‚îÇ   ‚îú‚îÄ‚îÄ models/        # Database models
‚îÇ   ‚îú‚îÄ‚îÄ routes/        # API route definitions
‚îÇ   ‚îú‚îÄ‚îÄ utils/         # Helper functions
‚îÇ   ‚îú‚îÄ‚îÄ app.js         # Express app configuration
‚îÇ   ‚îú‚îÄ‚îÄ constants.js   # App constants
‚îÇ   ‚îî‚îÄ‚îÄ index.js       # Server entry point
‚îú‚îÄ‚îÄ .env               # Environment variables
‚îú‚îÄ‚îÄ .gitignore         # Git ignore rules
‚îú‚îÄ‚îÄ .prettierrc        # Prettier configuration
‚îú‚îÄ‚îÄ .prettierignore    # Prettier ignore rules
‚îî‚îÄ‚îÄ package.json       # Project dependencies
```

---

# Project Structure Explained

## üìÇ Core Files

### **`src/index.js` - Server Entry Point**
```javascript
// Main server file - starts the application
import app from './app.js'
import connectDB from './db/index.js'

const PORT = process.env.PORT || 8000

connectDB()
.then(() => {
    app.listen(PORT, () => {
        console.log(`‚öôÔ∏è Server running on port: ${PORT}`)
    })
})
.catch((err) => {
    console.log("MongoDB connection failed!", err)
})
```

### **`src/app.js` - Express App Configuration**
```javascript
// Express app setup - middleware, routes, error handling
import express from 'express'
import cors from 'cors'
import cookieParser from 'cookie-parser'

const app = express()

// Middleware setup
app.use(cors())
app.use(express.json({limit: "16kb"}))
app.use(express.urlencoded({extended: true}))
app.use(cookieParser())

export default app
```

### **`src/constants.js` - Application Constants**
```javascript
// Centralized constants
export const DB_NAME = "playbackend"
export const CLOUDINARY_CLOUD_NAME = "your-cloud-name"
export const JWT_SECRET = process.env.JWT_SECRET
export const CORS_ORIGIN = process.env.CORS_ORIGIN
```

## üìÅ Core Folders

### **`models/` - Database Models**
```javascript
// Example: User model
import mongoose from 'mongoose'

const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        unique: true
    },
    email: {
        type: String,
        required: true,
        unique: true
    }
}, {timestamps: true})

export const User = mongoose.model("User", userSchema)
```

### **`controllers/` - Business Logic**
```javascript
// Handle request/response logic
const registerUser = async (req, res) => {
    // Registration logic here
    res.status(201).json({message: "User registered successfully"})
}

export { registerUser }
```

### **`routes/` - API Routes**
```javascript
// Define API endpoints
import { Router } from 'express'
import { registerUser } from '../controllers/user.controller.js'

const router = Router()
router.route("/register").post(registerUser)

export default router
```

### **`middlewares/` - Custom Middleware**
```javascript
// Authentication, validation, etc.
const verifyJWT = (req, res, next) => {
    // JWT verification logic
    next()
}

export { verifyJWT }
```

### **`utils/` - Helper Functions**
```javascript
// Reusable utility functions
export const asyncHandler = (requestHandler) => {
    return (req, res, next) => {
        Promise.resolve(requestHandler(req, res, next))
               .catch((err) => next(err))
    }
}
```

### **`db/` - Database Configuration**
```javascript
// Database connection setup
import mongoose from 'mongoose'
import { DB_NAME } from '../constants.js'

const connectDB = async () => {
    try {
        await mongoose.connect(`${process.env.MONGODB_URI}/${DB_NAME}`)
        console.log("MongoDB connected successfully!")
    } catch (error) {
        console.log("MongoDB connection error:", error)
        process.exit(1)
    }
}

export default connectDB
```

## üì¶ Public Folder Structure

### **`public/` - File Storage**
```
public/
‚îú‚îÄ‚îÄ temp/           # Temporary file uploads
‚îÇ   ‚îî‚îÄ‚îÄ .gitkeep   # Keep folder in git
‚îî‚îÄ‚îÄ uploads/        # Processed files
    ‚îú‚îÄ‚îÄ avatars/    # User profile pictures  
    ‚îú‚îÄ‚îÄ posts/      # Post images/videos
    ‚îî‚îÄ‚îÄ documents/  # Other files
```

### **Why This Structure?**
- **`temp/`**: Files before processing (multer uploads)
- **`uploads/`**: Processed files ready for use
- **Organized by type**: Easy to manage different file categories

---

# Development Dependencies

## üõ†Ô∏è Step 3: Install Development Tools

```bash
# Install development dependencies
npm install -D nodemon prettier

# Or using the -d flag (same as --save-dev)
npm install nodemon prettier -d
```

### **Development Dependencies Explained:**

#### **Nodemon**
```json
{
  "scripts": {
    "dev": "nodemon src/index.js",
    "start": "node src/index.js"
  }
}
```
**Benefits:**
- ‚úÖ Automatically restarts server on file changes
- ‚úÖ Speeds up development workflow
- ‚úÖ Only for development (not production)

#### **Prettier**
- ‚úÖ Consistent code formatting across team
- ‚úÖ Automatic code formatting on save
- ‚úÖ Reduces code review discussions about formatting

---

# Code Formatting Setup

## üé® Step 4: Prettier Configuration

### **Create `.prettierrc` file:**
```json
{
  "singleQuote": false,
  "bracketSpacing": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "semi": true,
  "printWidth": 80,
  "useTabs": false,
  "quoteProps": "as-needed",
  "jsxSingleQuote": false,
  "arrowParens": "always"
}
```

### **Create `.prettierignore` file:**
```
# Ignore build outputs
dist/
build/
coverage/

# Ignore dependencies
node_modules/

# Ignore environment files
.env
.env.local
.env.production

# Ignore logs
*.log
logs/

# Ignore OS generated files
.DS_Store
Thumbs.db

# Ignore temporary files
public/temp/
*.tmp
```

### **VS Code Integration:**
Add to `settings.json`:
```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  }
}
```

---

# File Handling Strategy

## üì∏ Third-Party Services for Images

### **Why Use Cloudinary/AWS?**
```javascript
// ‚ùå Don't store images directly in database
const userSchema = new mongoose.Schema({
    profilePicture: Buffer // Wrong approach!
})

// ‚úÖ Store URLs from cloud services
const userSchema = new mongoose.Schema({
    profilePicture: {
        type: String, // Cloudinary URL
        default: "https://res.cloudinary.com/default-avatar.jpg"
    }
})
```

### **Benefits of Cloud Storage:**
- ‚úÖ **Performance**: Faster image loading
- ‚úÖ **Scalability**: Handle thousands of images
- ‚úÖ **CDN**: Global content delivery
- ‚úÖ **Processing**: Automatic image optimization
- ‚úÖ **Storage**: Don't bloat your database

### **Popular Services:**
- **Cloudinary**: Easy integration, good free tier
- **AWS S3**: Enterprise-grade, extensive features  
- **Uploadcare**: Developer-friendly APIs

---

# Best Practices

## ‚úÖ Professional Development Standards

### **1. Environment Variables**
```bash
# .env file
PORT=8000
MONGODB_URI=mongodb://localhost:27017
JWT_SECRET=your-secret-key
CLOUDINARY_CLOUD_NAME=your-cloud-name
CLOUDINARY_API_KEY=your-api-key
CLOUDINARY_API_SECRET=your-api-secret
```

### **2. Git Configuration**
```bash
# .gitignore
node_modules/
.env
.env.local
.env.production
*.log
dist/
build/
public/temp/*
!public/temp/.gitkeep
```

### **3. Package.json Scripts**
```json
{
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "build": "npm run build:server",
    "test": "jest",
    "format": "prettier --write .",
    "format:check": "prettier --check ."
  }
}
```

### **4. Error Handling**
```javascript
// utils/ApiError.js
class ApiError extends Error {
    constructor(statusCode, message = "Something went wrong") {
        super(message)
        this.statusCode = statusCode
        this.data = null
        this.success = false
        this.errors = errors
    }
}
```

### **5. Response Structure**
```javascript
// utils/ApiResponse.js
class ApiResponse {
    constructor(statusCode, data, message = "Success") {
        this.statusCode = statusCode
        this.data = data
        this.message = message
        this.success = statusCode < 400
    }
}
```

---

# Professional Workflow Summary

## üéØ Step-by-Step Process

1. **üì± Analyze Figma Prototype**
   - Identify data requirements
   - Plan database relationships
   - Define API endpoints

2. **üèóÔ∏è Setup Project Structure**
   - Create professional folder organization
   - Setup entry points and configurations
   - Plan file storage strategy

3. **‚öôÔ∏è Configure Development Environment**
   - Install necessary dependencies
   - Setup code formatting (Prettier)
   - Configure development tools (Nodemon)

4. **üîí Setup Security & Environment**
   - Create environment variables
   - Configure Git ignore rules
   - Setup error handling

5. **üöÄ Start Development**
   - Build models based on analysis
   - Create controllers for business logic
   - Define routes for API endpoints
   - Add middleware for authentication

This systematic approach ensures you build scalable, maintainable backend applications that can handle real-world requirements professionally! üéâ