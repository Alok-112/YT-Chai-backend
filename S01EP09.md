# Custom API Response & Error Handling - Complete Production Guide

## 📋 Table of Contents
1. [Express App Configuration](#express-app-configuration)
2. [Understanding Middleware](#understanding-middleware)
3. [Data Handling & Security](#data-handling--security)
4. [Async Handler Implementation](#async-handler-implementation)
5. [Custom Error Handling](#custom-error-handling)
6. [Standardized API Responses](#standardized-api-responses)
7. [HTTP Status Codes Guide](#http-status-codes-guide)
8. [Production Implementation](#production-implementation)

---

# Express App Configuration

## 🚀 Basic Express Setup (`src/app.js`)

```javascript
import express from 'express'
import cors from 'cors'
import cookieParser from 'cookie-parser'

const app = express()

// ============= MIDDLEWARE CONFIGURATION =============
// (Order matters in middleware!)

// 1. CORS Configuration
app.use(cors({
    origin: process.env.CORS_ORIGIN,
    credentials: true
}))

// 2. JSON Body Parser
app.use(express.json({
    limit: "16kb" // Prevent large payload attacks
}))

// 3. URL Encoded Data Parser  
app.use(express.urlencoded({
    extended: true,
    limit: "16kb"
}))

// 4. Static Files Serving
app.use(express.static("public"))

// 5. Cookie Parser
app.use(cookieParser())

export default app
```

---

# Understanding Middleware

## 🔄 What Are Middlewares?

**Middleware = Functions that execute during the request-response lifecycle**

### **Express Request-Response Cycle:**
```
Request → Middleware 1 → Middleware 2 → Route Handler → Response
```

### **Core Request Objects:**

#### **`req.params` - URL Parameters**
```javascript
// Route: /users/:id
// URL: /users/123
console.log(req.params.id) // "123"
```

#### **`req.body` - Request Body Data**
```javascript
// POST request with JSON body
console.log(req.body) 
// { name: "John", email: "john@example.com" }
```

#### **`req.cookies` - Browser Cookies**
```javascript
// Cookies sent by browser
console.log(req.cookies.sessionId) // "abc123xyz"
```

### **Essential Dependencies:**

#### **`cookie-parser`**
```javascript
import cookieParser from 'cookie-parser'
app.use(cookieParser())

// Now you can access cookies
req.cookies.sessionId
req.cookies.authToken
```

#### **`cors` (Cross-Origin Resource Sharing)**
```javascript
import cors from 'cors'
app.use(cors({
    origin: "http://localhost:3000", // Frontend URL
    credentials: true // Allow cookies
}))
```

---

# Data Handling & Security

## 🛡️ Secure Data Processing

### **1. JSON Data Handling**
```javascript
app.use(express.json({
    limit: "16kb" // Prevent DoS attacks with large payloads
}))
```
**What it does:**
- ✅ Parses JSON request bodies
- ✅ Protects against large payload attacks  
- ✅ Makes `req.body` available for JSON data

### **2. URL Encoded Data Handling**
```javascript
app.use(express.urlencoded({
    extended: true,
    limit: "16kb"
}))
```

#### **URL Encoding Examples:**
```javascript
// When user searches: "alok thakur"
// Browser converts to: "alok+thakur" or "alok%20thakur"

// Original: Hello World!
// Encoded: Hello%20World%21

// Form data: name=john&email=john@example.com
// Parsed to: { name: "john", email: "john@example.com" }
```

**`extended: true` vs `extended: false`:**
- ✅ **`true`**: Can parse complex objects and arrays
- ❌ **`false`**: Only parses simple key-value pairs

### **3. Static File Serving**
```javascript
app.use(express.static("public"))
```
**Purpose:**
- 📁 Serves files from `public/` directory
- 🖼️ Images, CSS, JS files accessible via URL
- 🔗 `public/images/logo.png` → `http://localhost:3000/images/logo.png`

---

# Async Handler Implementation

## ⚡ Production-Grade Utility Function

### **`src/utils/asyncHandler.js`**

#### **Method 1: Try-Catch Approach (Recommended)**
```javascript
const asyncHandler = (fn) => async (req, res, next) => {
    try {
        await fn(req, res, next)
    } catch (error) {
        res.status(error.code || 500).json({
            success: false,
            message: error.message
        })
    }
}

export { asyncHandler }
```

#### **Method 2: Promise-Based Approach**
```javascript
const asyncHandler = (requestHandler) => {
    return (req, res, next) => {
        Promise.resolve(requestHandler(req, res, next))
               .catch((err) => next(err))
    }
}

export { asyncHandler }
```

### **How to Use Async Handler:**

#### **Without Async Handler (❌ Repetitive)**
```javascript
const getUser = async (req, res) => {
    try {
        const user = await User.findById(req.params.id)
        res.json(user)
    } catch (error) {
        res.status(500).json({ error: error.message })
    }
}

const createUser = async (req, res) => {
    try {
        const user = await User.create(req.body)
        res.json(user)
    } catch (error) {
        res.status(500).json({ error: error.message })
    }
}
```

#### **With Async Handler (✅ Clean & DRY)**
```javascript
import { asyncHandler } from '../utils/asyncHandler.js'

const getUser = asyncHandler(async (req, res) => {
    const user = await User.findById(req.params.id)
    res.json(user)
})

const createUser = asyncHandler(async (req, res) => {
    const user = await User.create(req.body)
    res.json(user)
})
```

---

# Custom Error Handling

## 🚨 Standardized Error Structure

### **`src/utils/ApiError.js`**
```javascript
class ApiError extends Error {
    constructor(
        statusCode,
        message = "Something went wrong",
        errors = [],
        stack = ""
    ) {
        super(message)

        this.statusCode = statusCode
        this.data = null
        this.success = false
        this.errors = errors

        if (stack) {
            this.stack = stack
        } else {
            Error.captureStackTrace(this, this.constructor)
        }
    }
}

export { ApiError }
```

### **Understanding Node.js Error Class:**
Based on: https://nodejs.org/api/error.html

#### **Key Properties:**
- **`message`**: Human-readable error description
- **`stack`**: Stack trace for debugging
- **`statusCode`**: HTTP status code (our custom addition)
- **`errors`**: Array of detailed errors (validation errors)
- **`success`**: Always false for errors

#### **`Error.captureStackTrace()` Explanation:**
```javascript
// Without captureStackTrace
Error: User not found
    at ApiError constructor (/utils/ApiError.js:15:9)  ← Shows constructor
    at getUserById (/controllers/user.js:25:15)        ← Actual error location

// With captureStackTrace  
Error: User not found
    at getUserById (/controllers/user.js:25:15)        ← Only shows actual error
```

### **Using Custom ApiError:**

#### **Basic Usage:**
```javascript
import { ApiError } from '../utils/ApiError.js'

// Simple error
throw new ApiError(404, "User not found")

// Detailed error with validation
throw new ApiError(
    400, 
    "Validation failed",
    [
        { field: "email", message: "Email is required" },
        { field: "password", message: "Password too short" }
    ]
)
```

#### **In Controllers:**
```javascript
const getUserById = asyncHandler(async (req, res) => {
    const { id } = req.params
    
    const user = await User.findById(id)
    
    if (!user) {
        throw new ApiError(404, "User not found")
    }
    
    res.json(new ApiResponse(200, user, "User retrieved successfully"))
})
```

---

# Standardized API Responses

## ✅ Consistent Response Structure

### **`src/utils/ApiResponse.js`**
```javascript
class ApiResponse {
    constructor(statusCode, data, message = "Success") {
        this.statusCode = statusCode
        this.data = data
        this.message = message
        this.success = statusCode < 400
    }
}

export { ApiResponse }
```

### **Enhanced Version with Metadata:**
```javascript
class ApiResponse {
    constructor(
        statusCode, 
        data, 
        message = "Success",
        pagination = null,
        meta = {}
    ) {
        this.statusCode = statusCode
        this.data = data
        this.message = message
        this.success = statusCode < 400
        this.timestamp = new Date().toISOString()
        
        // Optional pagination info
        if (pagination) {
            this.pagination = pagination
        }
        
        // Additional metadata
        this.meta = meta
    }
}

export { ApiResponse }
```

### **Usage Examples:**

#### **Simple Success Response:**
```javascript
import { ApiResponse } from '../utils/ApiResponse.js'

const getUsers = asyncHandler(async (req, res) => {
    const users = await User.find()
    
    return res
        .status(200)
        .json(new ApiResponse(200, users, "Users retrieved successfully"))
})
```

#### **Response with Pagination:**
```javascript
const getUsersPaginated = asyncHandler(async (req, res) => {
    const { page = 1, limit = 10 } = req.query
    
    const users = await User.find()
        .limit(limit * 1)
        .skip((page - 1) * limit)
    
    const total = await User.countDocuments()
    
    const pagination = {
        currentPage: parseInt(page),
        totalPages: Math.ceil(total / limit),
        totalItems: total,
        itemsPerPage: parseInt(limit)
    }
    
    return res
        .status(200)
        .json(new ApiResponse(
            200, 
            users, 
            "Users retrieved successfully",
            pagination
        ))
})
```

---

# HTTP Status Codes Guide

## 📊 Complete Status Code Reference

### **1xx - Informational Responses (100-199)**
```javascript
100 // Continue
101 // Switching Protocols
102 // Processing
```
**Usage:** Rarely used in REST APIs

### **2xx - Successful Responses (200-299)**
```javascript
const STATUS_CODES = {
    OK: 200,                    // GET requests successful
    CREATED: 201,              // POST requests successful
    ACCEPTED: 202,             // Request accepted, processing
    NO_CONTENT: 204,           // DELETE requests successful
    RESET_CONTENT: 205,        // Form reset successful
    PARTIAL_CONTENT: 206       // Range requests
}
```

#### **Usage Examples:**
```javascript
// GET request
res.status(200).json(new ApiResponse(200, data))

// POST request (resource created)
res.status(201).json(new ApiResponse(201, newUser, "User created"))

// DELETE request
res.status(204).send() // No content needed
```

### **3xx - Redirection Responses (300-399)**
```javascript
const REDIRECT_CODES = {
    MOVED_PERMANENTLY: 301,    // Resource moved permanently
    FOUND: 302,                // Temporary redirect
    NOT_MODIFIED: 304          // Cache validation
}
```

### **4xx - Client Error Responses (400-499)**
```javascript
const CLIENT_ERRORS = {
    BAD_REQUEST: 400,          // Invalid request data
    UNAUTHORIZED: 401,         // Authentication required
    FORBIDDEN: 403,            // Access denied
    NOT_FOUND: 404,            // Resource not found
    METHOD_NOT_ALLOWED: 405,   // Wrong HTTP method
    CONFLICT: 409,             // Resource conflict
    UNPROCESSABLE_ENTITY: 422, // Validation errors
    TOO_MANY_REQUESTS: 429     // Rate limiting
}
```

#### **Common Usage:**
```javascript
// Validation error
throw new ApiError(400, "Invalid email format")

// Authentication error
throw new ApiError(401, "Please login to access this resource")

// Authorization error
throw new ApiError(403, "You don't have permission to perform this action")

// Resource not found
throw new ApiError(404, "User not found")

// Validation errors
throw new ApiError(422, "Validation failed", [
    { field: "email", message: "Email is required" }
])
```

### **5xx - Server Error Responses (500-599)**
```javascript
const SERVER_ERRORS = {
    INTERNAL_SERVER_ERROR: 500, // Generic server error
    NOT_IMPLEMENTED: 501,       // Feature not implemented
    BAD_GATEWAY: 502,          // Gateway error
    SERVICE_UNAVAILABLE: 503,   // Service down
    GATEWAY_TIMEOUT: 504       // Gateway timeout
}
```

## 🏢 Industry Standards

### **Startup vs Company Approach:**

#### **In Startups:** 
- ❌ No standardized status codes
- ❌ Inconsistent error messages  
- ❌ Manual error handling everywhere

#### **In Companies:**
- ✅ **Status Code Specification Document**
- ✅ **Standardized Error Response Format**
- ✅ **Error Code Dictionary**
- ✅ **Automated Error Handling**

### **Example Company Status Code Spec:**
```javascript
// company-status-codes.js
export const HTTP_STATUS = {
    // Success
    SUCCESS: 200,
    CREATED: 201,
    
    // Client Errors
    VALIDATION_ERROR: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    
    // Server Errors
    INTERNAL_ERROR: 500,
    DATABASE_ERROR: 503
}

export const ERROR_MESSAGES = {
    VALIDATION_FAILED: "Request validation failed",
    USER_NOT_FOUND: "User does not exist",
    INVALID_CREDENTIALS: "Invalid email or password",
    ACCESS_DENIED: "Insufficient permissions"
}
```

---

# Production Implementation

## 🎯 Complete Error & Response System

### **Global Error Handler Middleware**
```javascript
// src/middlewares/errorHandler.js
import { ApiError } from '../utils/ApiError.js'

const errorHandler = (error, req, res, next) => {
    let err = error

    // If error is not our custom ApiError, make it one
    if (!(error instanceof ApiError)) {
        const statusCode = error.statusCode || 500
        const message = error.message || "Something went wrong"
        err = new ApiError(statusCode, message, error?.errors || [], error?.stack)
    }

    const response = {
        success: err.success,
        message: err.message,
        errors: err.errors,
        ...(process.env.NODE_ENV === "development" && { stack: err.stack })
    }

    return res.status(err.statusCode).json(response)
}

export { errorHandler }
```

### **Complete App Configuration**
```javascript
// src/app.js
import express from 'express'
import cors from 'cors'
import cookieParser from 'cookie-parser'
import { errorHandler } from './middlewares/errorHandler.js'

const app = express()

// Basic middleware
app.use(cors({ origin: process.env.CORS_ORIGIN, credentials: true }))
app.use(express.json({ limit: "16kb" }))
app.use(express.urlencoded({ extended: true, limit: "16kb" }))
app.use(express.static("public"))
app.use(cookieParser())

// Routes
import userRoutes from './routes/user.routes.js'
app.use('/api/v1/users', userRoutes)

// Global error handler (must be last)
app.use(errorHandler)

// Handle 404 routes
app.use('*', (req, res) => {
    res.status(404).json(new ApiResponse(404, null, `Route ${req.originalUrl} not found`))
})

export default app
```

### **Complete Controller Example**
```javascript
// src/controllers/user.controller.js
import { asyncHandler } from '../utils/asyncHandler.js'
import { ApiError } from '../utils/ApiError.js'
import { ApiResponse } from '../utils/ApiResponse.js'
import { User } from '../models/user.model.js'

const registerUser = asyncHandler(async (req, res) => {
    // Validation
    const { fullName, email, username, password } = req.body

    if ([fullName, email, username, password].some((field) => field?.trim() === "")) {
        throw new ApiError(400, "All fields are required")
    }

    // Check if user exists
    const existedUser = await User.findOne({
        $or: [{ username }, { email }]
    })

    if (existedUser) {
        throw new ApiError(409, "User with email or username already exists")
    }

    // Create user
    const user = await User.create({
        fullName,
        email: email.toLowerCase(),
        password,
        username: username.toLowerCase()
    })

    // Remove password from response
    const createdUser = await User.findById(user._id).select("-password -refreshToken")

    if (!createdUser) {
        throw new ApiError(500, "Something went wrong while registering the user")
    }

    return res
        .status(201)
        .json(new ApiResponse(201, createdUser, "User registered successfully"))
})

export { registerUser }
```

## 🔥 Key Benefits of This System:

1. **✅ Consistent Error Handling**: All errors follow same structure
2. **✅ Automatic Status Codes**: No manual status code management
3. **✅ Clean Controllers**: No repetitive try-catch blocks
4. **✅ Better Debugging**: Stack traces in development
5. **✅ Production Ready**: Secure error messages in production
6. **✅ Standardized Responses**: Frontend knows what to expect

This system is used by major tech companies and provides a solid foundation for scalable applications! 🚀