# Ecommerce & Hospital Management Data Modeling - Complete Study Guide

## Table of Contents
1. [Ecommerce Data Models](#ecommerce-data-models)
2. [Hospital Management Data Models](#hospital-management-data-models)
3. [Advanced Concepts](#advanced-concepts)
4. [Best Practices](#best-practices)

---

# Ecommerce Data Models

## Project Structure
```
models/
  ecommerce/
    user.models.js
    category.models.js
    product.models.js
    order.models.js
```

---

## 1. User Model (user.models.js)

```javascript
import mongoose from 'mongoose'

const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
    },
    email: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
    },
    password: {
        type: String,
        required: true,
    }
}, {
    timestamps: true
})

export const User = mongoose.model("User", userSchema)
```

### **Key Features:**
- **Username & Email**: Both unique and automatically lowercase
- **Password**: Required field (should be hashed in real applications)
- **Timestamps**: Automatic createdAt and updatedAt tracking

---

## 2. Category Model (category.models.js)

```javascript
import mongoose from 'mongoose'

const categorySchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
    }
}, {
    timestamps: true
})

export const Category = mongoose.model("Category", categorySchema)
```

### **Purpose:**
- **Product Organization**: Groups products into categories
- **Simple Structure**: Just name and timestamps
- **Scalable**: Can be extended with descriptions, images, parent categories

---

## 3. Product Model (product.models.js)

```javascript
import mongoose from 'mongoose'

const productSchema = new mongoose.Schema({
    description: {
        type: String,
        required: true,
    },
    name: {
        type: String,
        required: true,
    },
    productImage: {
        type: String, // URL/path to image
    },
    price: {
        type: Number,
        default: 0,
    },
    stock: {
        type: Number,
        default: 0,
    },
    category: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Category",
        required: true,
    },
    owner: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User"
    }
}, {
    timestamps: true
})

export const Product = mongoose.model("Product", productSchema)
```

### **Important Notes:**

#### **Image Storage Options:**
1. **âŒ Direct Database Storage**: Storing actual images in DB (not recommended)
2. **âœ… Third-party Services**: Cloudinary, AWS S3 (recommended)
3. **âœ… File System**: Store in folder, save URL/path in database

#### **MongoDB Naming Convention:**
- When you write `mongoose.model("Product")`, MongoDB automatically converts it to **"products"** (lowercase + plural)

#### **Relationships:**
- **Category Reference**: Each product belongs to one category
- **Owner Reference**: Links to the user who added the product

---

## 4. Order Model (order.models.js) - Complex Relationships

```javascript
import mongoose from 'mongoose'

// Mini-model for order items
const orderItemSchema = new mongoose.Schema({
    productId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Product"
    },
    quantity: {
        type: Number,
        required: true,
    }
})

const orderSchema = new mongoose.Schema({
    orderPrice: {
        type: Number,
        required: true,
    },
    customer: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User"
    },
    orderItems: {
        type: [orderItemSchema] // Array of order items
    },
    address: {
        type: String,
        required: true
    },
    status: {
        type: String,
        enum: ["PENDING", "CANCELLED", "DELIVERED"],
        default: "PENDING"
    }
}, {
    timestamps: true
})

export const Order = mongoose.model("Order", orderSchema)
```

### **Advanced Concepts Explained:**

#### **Mini-Models (Sub-schemas):**
**Problem**: How to handle multiple products in one order with different quantities?

**Solution**: Create a mini-schema inside the main schema
```javascript
const orderItemSchema = new mongoose.Schema({
    productId: { ... },
    quantity: { ... }
})
```

#### **Alternative Approach:**
```javascript
orderItems: {
    type: [{
        productId: { type: ObjectId, ref: "Product" },
        quantity: { type: Number, required: true }
    }]
}
```
**Why mini-models are better**: Cleaner code, better structure, easier maintenance in large codebases

#### **Enum Fields:**
**Problem**: Need to restrict order status to specific values

**Solution**: Use `enum` property
```javascript
status: {
    type: String,
    enum: ["PENDING", "CANCELLED", "DELIVERED"],
    default: "PENDING"
}
```

#### **Key Learning:**
> "Mongoose documentation should be read based on requirements. Reading all docs won't help - focus on what you need!"

---

# Hospital Management Data Models

## Project Structure
```
models/
  hospital-management/
    doctor.models.js
    patient.models.js
    hospital.models.js
    medical_records.models.js
```

---

## 1. Patient Model (patient.models.js)

```javascript
import mongoose from 'mongoose'

const patientSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
    },
    diagnosedWith: {
        type: String,
        required: true,
    },
    address: {
        type: String,
        required: true,
    },
    age: {
        type: Number,
        required: true,
    },
    bloodGroup: {
        type: String,
        required: true,
    },
    gender: {
        type: String,
        enum: ["M", "F", "O"], // Male, Female, Other
        required: true,
    },
    admittedIn: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Hospital"
    }
}, {
    timestamps: true
})

export const Patient = mongoose.model("Patient", patientSchema)
```

### **Key Features:**
- **Personal Information**: Name, age, gender, blood group
- **Medical Information**: Diagnosis and current hospital
- **Gender Enum**: Restricted to M/F/O for data consistency
- **Hospital Reference**: Links to the hospital where patient is admitted

---

## 2. Doctor Model (doctor.models.js)

```javascript
import mongoose from 'mongoose'

const doctorSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
    },
    salary: {
        type: Number, // Fixed: should be Number, not String
        required: true,
    },
    qualification: {
        type: String,
        required: true,
    },
    experienceInYears: {
        type: Number,
        default: 0
    },
    worksInHospitals: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: "Hospital"
        }
    ]
}, {
    timestamps: true
})

export const Doctor = mongoose.model("Doctor", doctorSchema)
```

### **Important Concept - Many-to-Many Relationship:**
- **One Doctor â†’ Multiple Hospitals**: A doctor can work in several hospitals
- **One Hospital â†’ Multiple Doctors**: A hospital has many doctors
- **Array of References**: `worksInHospitals: [{ ObjectId refs }]`

---

## 3. Hospital Model (hospital.models.js)

```javascript
import mongoose from 'mongoose'

const hospitalSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
    },
    addressLine1: {
        type: String,
        required: true,
    },
    addressLine2: {
        type: String,
    }, // Not always required
    city: {
        type: String,
        required: true,
    },
    pincode: {
        type: String,
        required: true,
    },
    specializedIn: [
        {
            type: String
        }
    ] // Array of specializations
}, {
    timestamps: true
})

export const Hospital = mongoose.model("Hospital", hospitalSchema)
```

### **Features:**
- **Complete Address**: Structured address with multiple lines
- **Specializations Array**: Hospital can have multiple specialties (Cardiology, Neurology, etc.)
- **Flexible Structure**: Easy to add more fields later

---

## 4. Medical Records Model (medical_records.models.js)

```javascript
import mongoose from 'mongoose'

const medicalRecordSchema = new mongoose.Schema({
    patient: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Patient",
        required: true
    },
    doctor: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Doctor",
        required: true
    },
    hospital: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Hospital",
        required: true
    },
    visitDate: {
        type: Date,
        default: Date.now
    },
    diagnosis: {
        type: String,
        required: true
    },
    treatment: {
        type: String,
    },
    prescription: [{
        medicine: {
            type: String,
            required: true
        },
        dosage: {
            type: String,
            required: true
        },
        duration: {
            type: String,
            required: true
        }
    }],
    notes: {
        type: String
    }
}, {
    timestamps: true
})

export const MedicalRecord = mongoose.model("MedicalRecord", medicalRecordSchema)
```

### **Enhanced Medical Records:**
*Note: Your original was empty, so I've added a complete medical record structure*

---

# Advanced Concepts

## 1. Relationship Types in These Models

### **One-to-One:**
- Patient â†’ Current Hospital (one patient admitted to one hospital at a time)

### **One-to-Many:**
- Category â†’ Products (one category has many products)
- User â†’ Orders (one user can have many orders)
- Hospital â†’ Patients (one hospital has many patients)

### **Many-to-Many:**
- Doctor â†” Hospital (doctors work in multiple hospitals, hospitals have multiple doctors)

## 2. Schema Design Patterns

### **Embedded Documents (Mini-Models):**
```javascript
// For closely related data that belongs together
orderItems: [orderItemSchema]
prescription: [{ medicine, dosage, duration }]
```

### **Referenced Documents:**
```javascript
// For independent entities that can exist separately
category: { type: ObjectId, ref: "Category" }
patient: { type: ObjectId, ref: "Patient" }
```

## 3. Data Validation Strategies

### **Enum for Restricted Values:**
```javascript
status: { enum: ["PENDING", "CANCELLED", "DELIVERED"] }
gender: { enum: ["M", "F", "O"] }
```

### **Default Values:**
```javascript
price: { default: 0 }
experienceInYears: { default: 0 }
status: { default: "PENDING" }
```

---

# Best Practices Summary

## âœ… Do's

1. **Plan Relationships First**: Understand how your entities connect
2. **Use Enums**: For fields with limited, known values
3. **Mini-Models**: For complex nested data (order items, prescriptions)
4. **Meaningful Names**: `diagnosedWith` not just `diagnosis`
5. **Proper Data Types**: Number for prices/salaries, not String
6. **Default Values**: Provide sensible defaults where applicable
7. **Timestamps**: Always include for audit trails

## âŒ Don'ts

1. **Don't Store Images Directly**: Use URLs/paths to external storage
2. **Don't Use String for Numbers**: Price, salary, age should be Number
3. **Don't Skip Validation**: Use required, unique, enum appropriately
4. **Don't Create Overly Complex Schemas**: Start simple, add complexity when needed

## ðŸ”§ Common Fixes Applied

- **Fixed typos**: `requried` â†’ `required`, `momgoose` â†’ `mongoose`
- **Fixed data types**: `salary: String` â†’ `salary: Number`
- **But if we want to give string in salaries as something like $ or Rupees**
- **Added missing commas** and proper syntax
- **Enhanced medical records** with proper structure
- **Added missing `timestamps: true`** where needed

## ðŸ’¡ Real-World Considerations

1. **Scalability**: These models can handle thousands of records
2. **Performance**: Consider indexing on frequently queried fields
3. **Security**: Hash passwords, validate inputs
4. **Extensibility**: Easy to add new fields without breaking existing data


## ðŸ’° Currency Handling Strategies

### **Option 1: Store Amount + Currency Separately (Recommended)**
```javascript
const doctorSchema = new mongoose.Schema({
    salary: {
        amount: {
            type: Number,
            required: true
        },
        currency: {
            type: String,
            enum: ["USD", "INR", "EUR", "GBP"],
            default: "INR"
        }
    }
})
```
**Benefits:**
- âœ… Can perform mathematical operations
- âœ… Easy currency conversion
- âœ… Database queries and sorting work properly
- âœ… Standardized currency codes

### **Option 2: Store as String (Your Suggestion)**
```javascript
const doctorSchema = new mongoose.Schema({
    salary: {
        type: String, // "â‚¹50000", "$5000"
        required: true
    }
})
```
**Benefits:**
- âœ… Simple to implement
- âœ… Direct display formatting
- âŒ Can't perform math operations easily
- âŒ Difficult to sort by salary amount
- âŒ Hard to filter (find salaries > â‚¹40000)

### **Option 3: Store Number + Add Currency in Frontend**
```javascript
const doctorSchema = new mongoose.Schema({
    salary: {
        type: Number, // 50000
        required: true
    },
    country: {
        type: String,
        enum: ["India", "USA", "UK"],
        default: "India"
    }
})
```
**Frontend handles display:**
```javascript
// In your frontend code
const displaySalary = (amount, country) => {
    switch(country) {
        case "India": return `â‚¹${amount}`
        case "USA": return `$${amount}`
        case "UK": return `Â£${amount}`
    }
}
```

### **Option 4: Hybrid Approach (Best for Complex Apps)**
```javascript
const doctorSchema = new mongoose.Schema({
    salary: {
        amount: {
            type: Number,
            required: true
        },
        currency: {
            type: String,
            enum: ["USD", "INR", "EUR", "GBP"],
            default: "INR"
        },
        formatted: {
            type: String // "â‚¹50,000" - auto-generated
        }
    }
})
```

## ðŸŽ¯ Real-World Recommendation

For **most applications**, I'd recommend **Option 1** (separate amount and currency) because:

```javascript
// Easy queries
const highPaidDoctors = await Doctor.find({
    "salary.amount": { $gte: 100000 },
    "salary.currency": "INR"
})

// Easy sorting
const sortedDoctors = await Doctor.find().sort({ "salary.amount": -1 })

// Easy calculations
const avgSalary = await Doctor.aggregate([
    { $match: { "salary.currency": "INR" } },
    { $group: { _id: null, avgSalary: { $avg: "$salary.amount" } } }
])
```

## ðŸ¤” When to Use String Approach?

Use `String` for salary when:
- **Simple display-only** requirements
- **No mathematical operations** needed
- **No sorting/filtering** by salary amount
- **Small, simple applications**



This comprehensive guide covers both basic and advanced MongoDB/Mongoose patterns you'll encounter in real applications!